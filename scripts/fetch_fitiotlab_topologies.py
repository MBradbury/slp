#!/usr/bin/env python
from __future__ import print_function

import json
import os
from pprint import pprint
import subprocess
import sys

from data.util import create_dirtree, touch

platform_mapping = {
    "wsn430v13": "wsn430:cc1101",
    "wsn430v14": "wsn430:cc2420",
}

archi_mapping = {v: k for (k, v) in platform_mapping.items()}

supported_platforms = platform_mapping.keys()
supported_hardware = platform_mapping.values()

output_directory = "data/testbed/info/fitiotlab/"

create_dirtree(output_directory)
touch("data/testbed/info/__init__.py")
touch(os.path.join(output_directory, "__init__.py"))

site_names = ["euratech", "grenoble", "rennes", "strasbourg"]

sites_support_script_execution = {"euratech", "grenoble", "strasbourg"}

# Saclay claims to have wsn430v14 nodes, but observing the 
# map at https://www.iot-lab.info/testbed/maps.php?site=saclay
# shows that there is only a single down node.
# So don't bother looking for nodes there.

class NodeDetails:

    @staticmethod
    def parse(obj, name, converter=lambda x: x):
        value = obj[name]
        if value == " ":
            return None
        else:
            return converter(value)

    def __init__(self, obj):
        self.archi = NodeDetails.parse(obj, "archi")
        self.uid = NodeDetails.parse(obj, "uid")
        self.mobile = NodeDetails.parse(obj, "mobile", bool)
        self.network_address = NodeDetails.parse(obj, "network_address")
        self.site = NodeDetails.parse(obj, "site")
        self.mobility_type = NodeDetails.parse(obj, "mobility_type")
        self.state = NodeDetails.parse(obj, "state")

        self.nid = int(self.network_address.split(".", 1)[0].split("-", 1)[1])

        try:
            self.coords = (float(obj["x"]), float(obj["y"]), float(obj["z"]))
        except ValueError:
            self.coords = None

    def __repr__(self):
        return "arch: {} | uid: {} | nid: {} | mobile: {} | addr: {} | site: {} | mobility: {} | state: {} | coords: {}".format(
            self.archi, self.uid, self.nid, self.mobile, self.network_address, self.site, self.mobility_type, self.state, self.coords)


def create_node_objects(obj):
    if "archi" in obj:
        return NodeDetails(obj)
    else:
        return obj

def process_site(site):
    print("Fetching topology for {}".format(site))

    path = os.path.join(output_directory, site + ".json")
    pypath = os.path.join(output_directory, site + ".py")

    with open(path, "w") as out_file:
       subprocess.check_call("experiment-cli info --site {} -l".format(site), stdout=out_file, shell=True)

    with open(path, "r") as out_file:
        nodes = json.load(out_file, object_hook=create_node_objects)["items"]

    nodes = [node for node in nodes if node.archi in supported_hardware and node.state in ("Alive", "Busy") and not node.mobile]

    if len(nodes) == 0:
        raise RuntimeError("No nodes are alive or busy or suspected on {}".format(site))

    platforms = {archi_mapping[node.archi] for node in nodes}

    if len(platforms) != 1:
        raise RuntimeError("Each testbed topology must consist of only 1 platform, {} are available on {}".format(platforms, site))

    with open(pypath, "w") as out_file:
        print('# Note this file was generated by {}.'.format(sys.argv[0]), file=out_file)
        print('# Please make changes to that script instead of editing this file.', file=out_file)
        print('', file=out_file)
        print('from itertools import groupby, count', file=out_file)
        print('', file=out_file)
        print('import numpy as np', file=out_file)
        print('', file=out_file)
        print('from simulator.Topology import Topology', file=out_file)
        print('', file=out_file)
        print('class {}(Topology):'.format(site.title()), file=out_file)
        print('    """The layout of nodes on the {} testbed, see: https://www.iot-lab.info/testbed/maps.php?site={}"""'.format(site.title(), site), file=out_file)
        print('', file=out_file)
        print('    platform = "{}"'.format(next(iter(platforms))), file=out_file)
        print('', file=out_file)
        print('    support_script_execution = {}'.format(site in sites_support_script_execution), file=out_file)
        print('', file=out_file)
        print('    def __init__(self, subset=None):', file=out_file)
        print('        super({}, self).__init__()'.format(site.title()), file=out_file)
        print('        ', file=out_file)

        for node in nodes:
            print('        self.nodes[{}] = np.array({}, dtype=np.float64)'.format(node.nid, node.coords), file=out_file)

        print('        ', file=out_file)

        print('        if subset is not None:', file=out_file)
        print('            to_keep = {x for l in (range(start, end+1) for (start, end) in subset) for x in l}', file=out_file)
        print('            for key in set(self.nodes) - to_keep:', file=out_file)
        print('                del self.nodes[key]', file=out_file)

        print('        ', file=out_file)
        print('        self._process_node_id_order("topology")', file=out_file)
        print('', file=out_file)

        print('    def node_ids(self):', file=out_file)
        print('        """Get the node id string that identifies which nodes are being used to the testbed."""', file=out_file)
        print('        # From: https://stackoverflow.com/questions/17415086/combine-consecutive-numbers-into-range-tuples', file=out_file)
        print('        groups = groupby(self.nodes.keys(), key=lambda item, c=count():item-next(c))', file=out_file)
        print('        temp = [list(g) for k, g in groups]', file=out_file)
        print('        return "+".join("{}-{}".format(x[0], x[-1]) for x in temp)', file=out_file)
        print('', file=out_file)

        print('    def __str__(self):', file=out_file)
        print('        return "{}<>"'.format(site.title()), file=out_file)
        print('', file=out_file)


for site in site_names:
    try:
        process_site(site)
    except RuntimeError as ex:
        print(ex)
